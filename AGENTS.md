# Инструкция для AI-агентов (Codex) по работе с проектом

Этот документ описывает правила разработки, архитектуры и стиля.
Цель — чтобы изменения, выполняемые агентами, выглядели так, как будто их написал разработчик проекта.

---

## 1. Технологический стек

Проект использует:

- **React** (функциональные компоненты)
- **TypeScript**
- **Jotai** для управления состоянием
- **Electron** (main / preload / renderer)
- **Vite** как сборщик
- Линтеры и форматтеры (ESLint)
  → Всегда использовать существующие конфигурации и не менять их без необходимости.

---

## 2. Язык интерфейса (обязательное правило)

Все тексты, которые видит пользователь, должны быть **на русском языке**:

- Заголовки
- Подписи
- Кнопки
- Плейсхолдеры
- Подсказки
- Уведомления
- Сообщения об ошибках

Комментарии, описывающие UI и бизнес-логику, также предпочтительно писать на русском.

**Нельзя** добавлять новые пользовательские тексты на английском языке.

**Допустимо** использовать английский в:

- внутренних логах для разработчиков (`console.error`, `console.warn`),
- технических идентификаторах и ключах,
- названиях переменных, функций, компонентов.

Примеры:

```tsx
// правильно
<Button>Сохранить</Button>

// неправильно
<Button>Save</Button>

// правильно
toast.error("Не удалось загрузить данные. Попробуйте ещё раз.")

// допустимо (лог для разработчика)
console.error("Failed to load projects", error);
```

---

## 3. Общие принципы разработки и React

### Общие правила

- Читаемость важнее краткости.
- Весь новый код пишется на **TypeScript**.
- Все компоненты React объявляются в виде `export const MyComponent: React.FC<Props> = ({ ... }) => { ... };`.
- Классовые компоненты **не используются**.
- Бизнес-логику по возможности выносить из JSX в функции и хуки.
- Не менять архитектуру и структуру проекта без явной необходимости.
- Предпочитать чистые функции и предсказуемые эффекты.
- Новые зависимости добавлять только при реальной необходимости и по возможности использовать уже имеющиеся утилиты и абстракции.

### React

#### Формат компонентов

- Компоненты с пропсами объявляются так:

  ```tsx
  interface Props {
      // ...
  }

  const ExampleComponent: React.FC<Props> = ({ ... }) => {
      ...
  };
  ```

- Если пропсов нет:

  ```tsx
  const ExampleComponent: React.FC = () => {
      ...
  };
  ```

#### Использование хуков

- Использовать стандартные хуки React:
  - `useState`
  - `useEffect`
  - `useMemo`
  - `useCallback`
  - `useRef`
  - `useContext`
- Общую логику выносить в **кастомные хуки** (`useSomething`).
- Как можно реже использовать `useEffect`

#### Рекомендации по JSX и структуре компонентов

- Не допускать большого количества сложной логики непосредственно в JSX.
- Списки всегда должны иметь стабильный `key`.
- Глубоко вложенный JSX (более 3–4 уровней) разбивать на подкомпоненты.
- Избегать «гигантских» компонентов: при усложнении UI выносить части в отдельные компоненты.

---

## 5. Jotai (состояние)

- Глобальное и межстраничное состояние — через **Jotai**.
- Локальное состояние простых компонентов — через `useState`.

<!-- ### Правила

- Атомы размещать в отдельных модулях (`atoms`, `state` или в соответствии с существующей структурой).
- Давать атомам осмысленные имена:
  `userSettingsAtom`, `projectsAtom`, `selectedProjectIdAtom` и т.п.
- Если атом влияет на UI, добавлять короткий комментарий на русском:

  ```ts
  // Текущий выбранный проект в списке
  export const selectedProjectIdAtom = atom<string | null>(null);
  ```

- При сложной логике работы с атомами (derive-атомы, async-атомы) — добавлять поясняющий комментарий.

--- -->

## 6. Electron

### Разделение контекстов

- **main** — создание окон, работа с ОС, системные вызовы.
- **preload** — безопасный мост между main и renderer.
- **renderer** — React-приложение (UI), без прямого доступа к Node API.

### Правила

- В React-коде (renderer) **не использовать** Node API напрямую.
- Не вызывать `ipcRenderer` напрямую внутри компонентов — только через явно описанный API из `preload`.
- При добавлении новых IPC-каналов:
  - описать их в одном месте (например, модуль с IPC-каналами),
  - типизировать запрос/ответ,
  - кратко задокументировать (на русском) назначение канала.
- Вся логика взаимодействия с системой (файлы, диалоги, пути и т.д.) должна быть изолирована от React-кода и доступна через абстракции.

---

## 7. Стиль кода

### Нейминг

- Компоненты: `PascalCase` (`ProjectList`, `SettingsModal`).
- Переменные и функции: `camelCase` (`loadProjects`, `handleClick`).
- Константы: `SCREAMING_SNAKE_CASE` или согласованный стиль, уже используемый в проекте (`DEFAULT_TIMEOUT`, `MAX_ITEMS` и т.п.).

### Типы и интерфейсы

- Для объектов и структур данных предпочтительно использовать `interface`:

  ```ts
  interface Project {
      id: string;
      name: string;
  }
  ```

- `type` использовать для:
  - объединений (`type Status = "idle" | "loading" | "error";`)
  - алиасов сложных типов
  - utility-типов.

### Комментарии

- Писать, только когда это действительно помогает понять код.
- На русском, если описывается логика/поведение.
- Не дублировать то, что уже очевидно из кода.

### Форматирование

- Использовать существующий стиль проекта и форматтер (Prettier и т.п.).
- Не изменять форматирование больших блоков кода без необходимости (чтобы не засорять диффы).

---

## 8. Работа с API, сетью и асинхронностью

- Все сетевые запросы и работу с внешними API выносить в отдельные модули (например, `services`).
- Не вызывать `fetch` или аналогичные функции напрямую из глубины UI, если уже есть абстракции для работы с API.
- Ошибки:
  - не игнорировать;
  - логировать технические детали в консоль или систему логирования;
  - пользователю показывать **краткое русскоязычное сообщение** без технических подробностей.

Пример:

```ts
try {
    const data = await api.loadProjects();
    // ...
} catch (error) {
    console.error("Failed to load projects", error);
    toast.error("Не удалось загрузить проекты. Попробуйте ещё раз.");
}
```

---

## 9. UI/UX

При добавлении/изменении UI учитывать:

- **Состояния:**
  - загрузка (`isLoading`)
  - успешная загрузка
  - ошибка (`error`)
  - пустой список/данные

- **Сообщения пользователю:**
  - на русском;
  - краткие;
  - нейтральные, без жаргона.

- **Опасные действия** (удаление, сброс настроек и т.п.):
  - должны быть визуально отличимы (кнопки/акценты);
  - по возможности запрашивать подтверждение.

Примеры формулировок:

- Хорошо: `Не удалось сохранить изменения. Попробуйте ещё раз.`
- Плохо: `Сохранение упало, хз почему.`

---
<!--
## 10. Тестирование

Если в проекте уже есть тесты:

- придерживаться существующего подхода (инструменты, структура, паттерны);
- при изменении логики по возможности обновлять/добавлять тесты.

Предпочтительные области для тестов:

- утилиты и чистые функции;
- критичная бизнес-логика;
- компоненты с нетривиальным поведением (если есть подходящая инфраструктура).

Не нужно переписывать весь тестовый набор, если задача локальная.

---

## 11. Работа с существующим кодом

- Перед изменениями — разобраться, как код используется (поиск по проекту, просмотр вызовов).
- Делать изменения **как можно более локально**, если задача не требует рефакторинга.
- Если без рефакторинга не обойтись:
  - проводить его поэтапно;
  - не менять поведение без необходимости;
  - по возможности разделять «рефакторинг» и «функциональные изменения».

---

## 12. Запрещено

- Добавлять новые тексты UI на английском.
- Использовать классовые компоненты React.
- Использовать `require` вместо `import`.
- Использовать Node API внутри React-кода (renderer).
- Менять структуру проекта без веской причины.
- Подмешивать нерелевантные изменения (например, массовый рефакторинг стиля в задачу на правку бага).
- Добавлять зависимости без необходимости, если задачу можно решить средствами уже существующего стека.

---

## 13. Дополнительные рекомендации

- Если есть соглашения по коммитам (например, conventional commits) — придерживаться их:
  - `feat: ...`, `fix: ...`, `chore: ...` и т.п.
- Для обработчиков событий использовать единый стиль:
  `handleX` для внутренних функций, `onX` для пропсов.
- При работе с состоянием избегать «магических чисел» и строк, выносить их в константы с понятными именами.

--- -->

Конец документа.
